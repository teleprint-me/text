"""
text_extraction/cli/json.py

A script for formatting conversational data into plaintext format for building language model vocabularies.
"""

import argparse
import json
from typing import Any, Dict, List


def read(input_file: str) -> List[Dict[str, str]]:
    """Read the JSON source file into memory for further processing."""

    try:
        with open(input_file, "r") as file:
            # just return data because there's nothing else to do
            return json.load(file)
    except (FileNotFoundError, json.JSONDecodeError):
        raise FileNotFoundError(f"Failed to read or parse {input_file}")


def write(output_file: str, plaintext: str) -> None:
    """Write the plaintext formatted output to a file."""

    try:
        with open(output_file, "w") as file:
            # write the concatenated results to the plaintext file
            file.write(plaintext)
            # notify the user of completion
            print(f"Output written to {output_file}")
    except (TypeError, IOError):
        raise TypeError(f"Failed to write {output_file}")


def is_conversational_format(data: List[Dict[str, str]]) -> bool:
    """Validate the conversational format of the provided data."""

    if not isinstance(data, list):
        return False

    if not isinstance(data[0], dict):
        return False

    # get the first element from the list
    element = data[0]
    # we expect the element to have a role and content key
    if "role" not in element or "content" not in element:
        return False  # We don't have the expected conversational format

    # get the role from the first element to ensure it's not a fluke
    if element["role"] not in ["user", "assistant", "system", "function"]:
        return False  # We don't know what format the conversation is in

    return True  # Assume it's okay to proceed


# NOTE: This is a lazy evaluation because there's no way to guarantee that it's a JSON file generated by OpenAI unless they implement a special key for doing so.
def is_openai_format(data: List[Dict[str, Any]]) -> bool:
    """Validate the OpenAI format of the provided data."""

    if not isinstance(data, list):
        raise TypeError("Data must be a list")

    if not isinstance(data[0], dict):
        raise TypeError("Data element must be a dictionary")

    # get an element from the list
    element = data[0]
    # dictionary should have an "id" and "mapping"
    if "id" not in element or "mapping" not in element:
        return False  # There are no "id" and/or "mapping" keys

    # get a key from the mapping. we only need one.
    key = list(element["mapping"].keys())[0]
    # split key uuid into parts
    key_parts = key.split("-")
    # uuids have 5 parts and each part is alphanumeric
    if 5 != len(key_parts) or not key_parts[0].isalnum():
        return False  # It's not a UUID

    return True


def format_conversation(data: List[Dict[str, str]]) -> str:
    """Format the JSON dataset into a string."""
    # set a string to concatenate results to
    plaintext = ""
    # iterate over each message in the list
    for element in data:
        # extract the message components from the element
        role, content = element.items()
        # concatenate the message to the string
        plaintext += f"{role}\n{content}\n"
    # return the formatted conversation as a string
    return plaintext


def format_openai(data: List[Dict[str, Any]]) -> str:
    # set a string to concatenate results to
    plaintext = ""
    # iterate over each record in the dataset
    for record in data:
        # extract the mapping from the dataset
        mapping = record["mapping"]
        # discover the message author and content
        # NOTE: key is a uuid that references another mapping
        for _, value in mapping.items():
            # value is the mapping that key is referencing
            message = value.get("message")
            # NOTE: message can be null
            if message:
                # attempt to extract the role and content from the data structure
                role = message.get("author", {}).get("role", "")
                content = "\n".join(
                    [part for part in message.get("content", {}).get("parts", [])]
                )
                # NOTE: role and content can be empty
                if role and content:
                    # concatenate the extracted data
                    plaintext += f"{role}\n{content}\n\n"
    return plaintext


def format_conversational_data(input_file: str, output_file: str) -> None:
    """Format the input JSON file according to one of the supported formats and write the result to an output file."""

    data = read(input_file)

    if is_conversational_format(data):
        # just call write because it's already in the expected format
        plaintext = format_conversation(data)
    elif is_openai_format(data):
        # we need to convert the dataset to the expected format
        plaintext = format_openai(data)
    else:
        raise ValueError("Unsupported input format")

    write(output_file, plaintext)


def get_parser_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-i",
        "--input-file",
        type=str,
        help="The input file to format",
    )
    parser.add_argument(
        "-o",
        "--output-file",
        type=str,
        help="The formatted output file.",
    )
    return parser.parse_args()


def main() -> None:
    args = get_parser_arguments()
    format_conversational_data(args.input_file, args.output_file)


if __name__ == "__main__":
    main()
